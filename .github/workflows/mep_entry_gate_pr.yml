name: ENTRY_GATE
on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
permissions:
  contents: read
  pull-requests: write
jobs:
  gate:
    name: ENTRY_GATE / gate
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: SSOT_SCAN + CONFLICT_SCAN (ENTRY)
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $ErrorActionPreference = 'Stop'
          function Fail([string]$code, [string]$msg) {
            Write-Host "::error title=$code::$msg"
            exit 1
          }
          # SSOT_SCAN (must exist)
          $ssot = 'docs/MEP/MEP_SSOT_MASTER.md'
          if (-not (Test-Path -LiteralPath $ssot)) {
            Fail 'WB0001' ("SSOT_SCAN failed: SSOT not found (" + $ssot + ").")
          }
          # CONFLICT_SCAN (diff-scope only)
          git fetch origin main --prune | Out-Null
          $files = @(git diff --name-only origin/main...HEAD)
          if (-not $files -or $files.Count -eq 0) {
            Write-Host "ENTRY OK (no changes?)"
            exit 0
          }
          # Legacy execution-candidate sources (sealed unless explicitly used)
          $legacyPaths = @(
            'docs/MEP/SSOT/WORK_ID_SSOT.json',
            'docs/MEP/SSOT/WORK_ID_SSOT.schema.json',
            'docs/MEP/SSOT/WORK_ID_SSOT_MASTER.json',
            'docs/MEP/SSOT/WORK_ID_SSOT_MASTER.schema.json',
            'docs/MEP/WORK_ID/'
          )
          # New execution-candidate sources (active)
          $newPaths = @(
            'docs/MEP/SSOT/WORK_ITEMS.json',
            'docs/MEP/SSOT/WORK_ITEMS.schema.json',
            'docs/MEP/WORK_ITEMS/',
            'tools/mep_entry.ps1'
          )
          function HasAny([string[]]$list, [string[]]$prefixes){
            foreach($f in $list){
              foreach($p in $prefixes){
                if ($p.EndsWith('/')) {
                  if ($f.Replace('\','/').StartsWith($p)) { return $true }
                } else {
                  if ($f.Replace('\','/') -eq $p) { return $true }
                }
              }
            }
            return $false
          }
          $legacyTouched = HasAny $files $legacyPaths
          $newTouched    = HasAny $files $newPaths
          if ($legacyTouched -and $newTouched) {
            Fail 'WB0001' "CONFLICT_SCAN failed (diff-scope): legacy+new execution candidate sources modified in same PR."
          }
          Write-Host "ENTRY OK"
