# MEP HANDOFF (NO-DRIFT) v3.3 (self-heal docs PRs; no here-strings; no GraphQL)
# - 100/100 以外は CURRENT を出さない（汚染停止）。
# - open PR が残っている場合、docs/MEP/** と START_HERE.md のみ変更するPRに限り自動収束（checks待ち + rerun failure + merge）。
# - docs/MEP 以外の変更を含む open PR があれば即停止（人間判断）。

param([switch]$WithIssue,[int]$IssueNumber=0,[int]$MaxRounds=6,[int]$SleepSec=5,[int]$WaitRounds=60)
$ErrorActionPreference="Stop"
$ProgressPreference="SilentlyContinue"
$env:GH_PAGER="cat"
[Console]::OutputEncoding=[System.Text.Encoding]::UTF8
try { $PSNativeCommandUseErrorActionPreference = $false } catch {}
function Need($cmd){ if(-not (Get-Command $cmd -ErrorAction SilentlyContinue)){ throw "Missing command: $cmd" } }
Need git; Need gh; if(-not (Test-Path ".git")){ throw "Run at repo root (where .git exists)." }

function Sync-MainHard {
  cmd /c "git rebase --abort 1>nul 2>nul" | Out-Null
  cmd /c "git merge  --abort 1>nul 2>nul" | Out-Null
  cmd /c "git cherry-pick --abort 1>nul 2>nul" | Out-Null
  cmd /c "git fetch origin main 1>nul 2>nul" | Out-Null
  cmd /c "git checkout main 1>nul 2>nul" | Out-Null
  cmd /c "git reset --hard origin/main 1>nul 2>nul" | Out-Null
  cmd /c "git clean -fd 1>nul 2>nul" | Out-Null
  if(git status --porcelain){ throw "Working tree is not clean after reset (locks/R/O likely). Close OneDrive/editor locks and retry." }
}

function Get-Repo {
  $raw = (& gh repo view --json nameWithOwner 2>$null | Out-String).Trim()
  if(-not $raw){ throw "gh repo view failed. Run: gh auth status" }
  return ((($raw | ConvertFrom-Json).nameWithOwner) | Out-String).Trim()
}

function List-OpenPrs([string]$repo){
  $raw = (& gh pr list --repo $repo --state open --base main --limit 200 --json "number,title,url,author,isDraft" 2>$null | Out-String).Trim()
  if(-not $raw){ return @() }
  if(-not $raw.StartsWith("[")){ throw "PR list JSON corrupted (not an array). Stop to prevent drift." }
  return @($raw | ConvertFrom-Json)
}

function Get-PrView([string]$repo,[int]$n){
  return (gh pr view $n --repo $repo --json "number,title,url,author,isDraft,mergeStateStatus,mergeable,statusCheckRollup" 2>$null | ConvertFrom-Json)
}

function Checks-AllOk($p){
  $roll=@($p.statusCheckRollup); if($roll.Count -eq 0){ return $false }
  foreach($c in $roll){ if($c.conclusion -notin @("SUCCESS","SKIPPED","NEUTRAL")){ return $false } }
  return $true
}

function Get-PrFiles([string]$repo,[int]$n){
  $api="repos/$repo/pulls/$n/files?per_page=100"
  $raw=(& gh api $api 2>$null | Out-String).Trim()
  if(-not $raw){ return @() }
  $arr=@($raw | ConvertFrom-Json)
  $files=@(); foreach($x in $arr){ if($x.filename){ $files+=[string]$x.filename } }
  return $files
}

function Is-SafeDocsOnly([string[]]$files){
  if($files.Count -eq 0){ return $false }
  foreach($f in $files){ if($f -like "docs/MEP/*"){ continue }; if($f -eq "START_HERE.md"){ continue }; return $false }
  return $true
}

function Extract-FailedRunIds($p){
  $ids=New-Object System.Collections.Generic.HashSet[string]
  foreach($c in @($p.statusCheckRollup)){ if($c.conclusion -ne "FAILURE"){ continue }; $u=$c.detailsUrl; if(-not $u){ continue }; $m=[regex]::Match($u,"actions/runs/(\d+)"); if($m.Success){ [void]$ids.Add($m.Groups[1].Value) } }
  return @($ids)
}

function Rerun-Run([string]$repo,[string]$runId){ & gh run rerun $runId --repo $repo --failed 2>$null | Out-Null }
function Wait-Run([string]$repo,[string]$runId,[int]$maxRounds,[int]$sleepSec){
  for($i=1;$i -le $maxRounds;$i++){
    $raw=(& gh run view $runId --repo $repo --json "status,conclusion" 2>$null | Out-String).Trim()
    if($raw){ $r=$raw|ConvertFrom-Json; if($r.status -eq "completed"){ return $r } }
    Start-Sleep -Seconds $sleepSec
  }
  return $null
}

# ===== main =====
Sync-MainHard
$repo=Get-Repo
$createdAtUtc=(Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
$head=(git rev-parse --short HEAD).Trim()
$idRand=([Guid]::NewGuid().ToString("N").Substring(0,8))
$handoffId=("HOF:{0}-{1}-{2}" -f (Get-Date -Format "yyyyMMdd-HHmmss"),$head,$idRand)

for($round=1; $round -le $MaxRounds; $round++){
  Sync-MainHard
  $open=@(List-OpenPrs $repo)
  if($open.Count -eq 0){ break }
  Write-Host ("[self-heal {0}/{1}] open PR(base main)={2}" -f $round,$MaxRounds,$open.Count)
  foreach($x in $open){
    # MEP HANDOFF (NO-DRIFT) v3.3 (self-heal docs PRs; no here-strings; no GraphQL)
# - 100/100 以外は CURRENT を出さない（汚染停止）。
# - open PR が残っている場合、docs/MEP/** と START_HERE.md のみ変更するPRに限り自動収束（checks待ち + rerun failure + merge）。
# - docs/MEP 以外の変更を含む open PR があれば即停止（人間判断）。

param([switch]$WithIssue,[int]$IssueNumber=0,[int]$MaxRounds=6,[int]$SleepSec=5,[int]$WaitRounds=60)
$ErrorActionPreference="Stop"
$ProgressPreference="SilentlyContinue"
$env:GH_PAGER="cat"
[Console]::OutputEncoding=[System.Text.Encoding]::UTF8
try { $PSNativeCommandUseErrorActionPreference = $false } catch {}
function Need($cmd){ if(-not (Get-Command $cmd -ErrorAction SilentlyContinue)){ throw "Missing command: $cmd" } }
Need git; Need gh; if(-not (Test-Path ".git")){ throw "Run at repo root (where .git exists)." }

function Sync-MainHard {
  cmd /c "git rebase --abort 1>nul 2>nul" | Out-Null
  cmd /c "git merge  --abort 1>nul 2>nul" | Out-Null
  cmd /c "git cherry-pick --abort 1>nul 2>nul" | Out-Null
  cmd /c "git fetch origin main 1>nul 2>nul" | Out-Null
  cmd /c "git checkout main 1>nul 2>nul" | Out-Null
  cmd /c "git reset --hard origin/main 1>nul 2>nul" | Out-Null
  cmd /c "git clean -fd 1>nul 2>nul" | Out-Null
  if(git status --porcelain){ throw "Working tree is not clean after reset (locks/R/O likely). Close OneDrive/editor locks and retry." }
}

function Get-Repo {
  $raw = (& gh repo view --json nameWithOwner 2>$null | Out-String).Trim()
  if(-not $raw){ throw "gh repo view failed. Run: gh auth status" }
  return ((($raw | ConvertFrom-Json).nameWithOwner) | Out-String).Trim()
}

function List-OpenPrs([string]$repo){
  $raw = (& gh pr list --repo $repo --state open --base main --limit 200 --json "number,title,url,author,isDraft" 2>$null | Out-String).Trim()
  if(-not $raw){ return @() }
  if(-not $raw.StartsWith("[")){ throw "PR list JSON corrupted (not an array). Stop to prevent drift." }
  return @($raw | ConvertFrom-Json)
}

function Get-PrView([string]$repo,[int]$n){
  return (gh pr view $n --repo $repo --json "number,title,url,author,isDraft,mergeStateStatus,mergeable,statusCheckRollup" 2>$null | ConvertFrom-Json)
}

function Checks-AllOk($p){
  $roll=@($p.statusCheckRollup); if($roll.Count -eq 0){ return $false }
  foreach($c in $roll){ if($c.conclusion -notin @("SUCCESS","SKIPPED","NEUTRAL")){ return $false } }
  return $true
}

function Get-PrFiles([string]$repo,[int]$n){
  $api="repos/$repo/pulls/$n/files?per_page=100"
  $raw=(& gh api $api 2>$null | Out-String).Trim()
  if(-not $raw){ return @() }
  $arr=@($raw | ConvertFrom-Json)
  $files=@(); foreach($x in $arr){ if($x.filename){ $files+=[string]$x.filename } }
  return $files
}

function Is-SafeDocsOnly([string[]]$files){
  if($files.Count -eq 0){ return $false }
  foreach($f in $files){ if($f -like "docs/MEP/*"){ continue }; if($f -eq "START_HERE.md"){ continue }; return $false }
  return $true
}

function Extract-FailedRunIds($p){
  $ids=New-Object System.Collections.Generic.HashSet[string]
  foreach($c in @($p.statusCheckRollup)){ if($c.conclusion -ne "FAILURE"){ continue }; $u=$c.detailsUrl; if(-not $u){ continue }; $m=[regex]::Match($u,"actions/runs/(\d+)"); if($m.Success){ [void]$ids.Add($m.Groups[1].Value) } }
  return @($ids)
}

function Rerun-Run([string]$repo,[string]$runId){ & gh run rerun $runId --repo $repo --failed 2>$null | Out-Null }
function Wait-Run([string]$repo,[string]$runId,[int]$maxRounds,[int]$sleepSec){
  for($i=1;$i -le $maxRounds;$i++){
    $raw=(& gh run view $runId --repo $repo --json "status,conclusion" 2>$null | Out-String).Trim()
    if($raw){ $r=$raw|ConvertFrom-Json; if($r.status -eq "completed"){ return $r } }
    Start-Sleep -Seconds $sleepSec
  }
  return $null
}

# ===== main =====
Sync-MainHard
$repo=Get-Repo
$createdAtUtc=(Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
$head=(git rev-parse --short HEAD).Trim()
$idRand=([Guid]::NewGuid().ToString("N").Substring(0,8))
$handoffId=("HOF:{0}-{1}-{2}" -f (Get-Date -Format "yyyyMMdd-HHmmss"),$head,$idRand)

for($round=1; $round -le $MaxRounds; $round++){
  Sync-MainHard
  $open=@(List-OpenPrs $repo)
  if($open.Count -eq 0){ break }
  Write-Host ("[self-heal {0}/{1}] open PR(base main)={2}" -f $round,$MaxRounds,$open.Count)
  foreach($x in $open){
    $n=[int]$x.number
    $files=@(Get-PrFiles $repo $n)
    if(-not (Is-SafeDocsOnly $files)){
      Write-Host ("STOP: non-docs change PR exists: #{0} {1} {2}" -f $n,$x.title,$x.url)
      Write-Host "changed files:"; foreach($f in $files){ Write-Host ("- {0}" -f $f) }
      throw "Not 100/100. Stop."
    }
    for($attempt=1; $attempt -le 3; $attempt++){
      $p=Get-PrView $repo $n; if(-not $p){ throw ("Failed to read PR #{0}" -f $n) }
      if(Checks-AllOk $p){ break }
      $failed=@(Extract-FailedRunIds $p)
      foreach($rid in $failed){
        Write-Host ("RERUN: runId={0} (https://github.com/{1}/actions/runs/{0})" -f $rid,$repo)
        Rerun-Run $repo $rid
        $r=Wait-Run $repo $rid $WaitRounds $SleepSec
        if(-not $r){ throw ("STOP: timeout runId={0}" -f $rid) }
        if($r.conclusion -ne "success"){ throw ("STOP: run still failing runId={0}" -f $rid) }
      }
    }
    $p=Get-PrView $repo $n; if(-not (Checks-AllOk $p)){ throw ("STOP: checks still not OK: #{0} {1}" -f $n,$x.url) }
    Write-Host ("MERGE: #{0} {1}" -f $n,$x.url)
    & gh pr merge $n --repo $repo --squash --delete-branch 2>$null | Out-Null
  }
}

Sync-MainHard
$open=@(List-OpenPrs $repo)
$openCount=$open.Count
$biz="platform/MEP/03_BUSINESS/よりそい堂/business_spec.md"
$requiredHeadings=@("## Order Lifecycle Controls（Phase-2）— 欠番/削除/復旧/誤完了解除（トゥームストーン方式）","### タスク投影（Todoist/ClickUp）— ライフサイクル表示と完了/復旧（固定）","### コメントモード（モード固定）— 入力待ち・実行・キャンセル（Phase-2｜固定）","### トリガー一覧（Phase-2｜固定）","### 欠番/削除モード（最終仕様）— FIX連携・解放/凍結境界・復旧（Phase-2｜固定）")
$missing=@(); if(Test-Path $biz){ $txt=Get-Content -Raw -Encoding UTF8 $biz; foreach($h in $requiredHeadings){ if($txt -notlike ("*"+$h+"*")){ $missing+=$h } } } else { $missing=$requiredHeadings }
$requiredPrs=@(535,539,541,542,543,544)
$bad=@(); foreach($n in $requiredPrs){ try { $p=(gh pr view $n --repo $repo --json "state,baseRefName,mergedAt" 2>$null|ConvertFrom-Json); $ok=($p.state -eq "MERGED" -and $p.baseRefName -eq "main" -and $p.mergedAt); if(-not $ok){ $bad+=$n } } catch { $bad+=$n } }
$score=100; if($openCount -gt 0){ $score-=20 }; if($missing.Count -gt 0){ $score-=30 }; if($bad.Count -gt 0){ $score-=30 }; if($score -lt 0){ $score=0 }
if($score -ne 100){ Write-Host ("HANDOFF_ID: {0}" -f $handoffId); Write-Host ("CREATED_AT_UTC: {0}" -f $createdAtUtc); Write-Host ("HANDOFF_SCORE={0}/100" -f $score); Write-Host ("- open PR(base main)={0}" -f $openCount); if($openCount -gt 0){ foreach($x in $open){ $a=""; try{$a=$x.author.login}catch{}; Write-Host ("  - #{0} {1} ({2}) {3}" -f $x.number,$x.title,$a,$x.url) } }; throw "Not 100/100. Stop." }
$head=(git rev-parse --short HEAD).Trim()
$out=New-Object System.Collections.Generic.List[string]
$out.Add("HANDOFF_ID: " + $handoffId)
$out.Add("CREATED_AT_UTC: " + $createdAtUtc)
$out.Add("REPO: " + $repo)
$out.Add("HEAD: " + $head)
$out.Add("OPEN_PR: 0")
$out.Add("HANDOFF_SCORE=100/100")
$out.Add("BUNDLE: docs/MEP/CHAT_PACKET_BUNDLE.md")
$out.Add("")
$out.Add("【CURRENT｜引っ越し再開用】")
$out.Add("")
$out.Add("Repo: " + $repo)
$out.Add("状態: main clean / open PR 0 / 最新HEAD=" + $head)
$out.Add("")
$out.Add("完了（main反映済み）")
$out.Add("- Comment Concierge / 欠番・削除・トリガー・モード運用は business_spec 側で仕様確定済み（PR #535/#539/#541/#542/#543/#544 が main=MERGED）")
$out.Add("- 次の作業（推奨）：実装計画へ移行（削除モード/FREEZE/Request(FIX) の「台帳反映（列/ステータス/ログ）」を master_spec 側へ落とす：1テーマ=1PR）")
$packet = ($out -join "`n") + "`n"
Write-Host $packet
_tmp = $x.number
if (# MEP HANDOFF (NO-DRIFT) v3.3 (self-heal docs PRs; no here-strings; no GraphQL)
# - 100/100 以外は CURRENT を出さない（汚染停止）。
# - open PR が残っている場合、docs/MEP/** と START_HERE.md のみ変更するPRに限り自動収束（checks待ち + rerun failure + merge）。
# - docs/MEP 以外の変更を含む open PR があれば即停止（人間判断）。

param([switch]$WithIssue,[int]$IssueNumber=0,[int]$MaxRounds=6,[int]$SleepSec=5,[int]$WaitRounds=60)
$ErrorActionPreference="Stop"
$ProgressPreference="SilentlyContinue"
$env:GH_PAGER="cat"
[Console]::OutputEncoding=[System.Text.Encoding]::UTF8
try { $PSNativeCommandUseErrorActionPreference = $false } catch {}
function Need($cmd){ if(-not (Get-Command $cmd -ErrorAction SilentlyContinue)){ throw "Missing command: $cmd" } }
Need git; Need gh; if(-not (Test-Path ".git")){ throw "Run at repo root (where .git exists)." }

function Sync-MainHard {
  cmd /c "git rebase --abort 1>nul 2>nul" | Out-Null
  cmd /c "git merge  --abort 1>nul 2>nul" | Out-Null
  cmd /c "git cherry-pick --abort 1>nul 2>nul" | Out-Null
  cmd /c "git fetch origin main 1>nul 2>nul" | Out-Null
  cmd /c "git checkout main 1>nul 2>nul" | Out-Null
  cmd /c "git reset --hard origin/main 1>nul 2>nul" | Out-Null
  cmd /c "git clean -fd 1>nul 2>nul" | Out-Null
  if(git status --porcelain){ throw "Working tree is not clean after reset (locks/R/O likely). Close OneDrive/editor locks and retry." }
}

function Get-Repo {
  $raw = (& gh repo view --json nameWithOwner 2>$null | Out-String).Trim()
  if(-not $raw){ throw "gh repo view failed. Run: gh auth status" }
  return ((($raw | ConvertFrom-Json).nameWithOwner) | Out-String).Trim()
}

function List-OpenPrs([string]$repo){
  $raw = (& gh pr list --repo $repo --state open --base main --limit 200 --json "number,title,url,author,isDraft" 2>$null | Out-String).Trim()
  if(-not $raw){ return @() }
  if(-not $raw.StartsWith("[")){ throw "PR list JSON corrupted (not an array). Stop to prevent drift." }
  return @($raw | ConvertFrom-Json)
}

function Get-PrView([string]$repo,[int]$n){
  return (gh pr view $n --repo $repo --json "number,title,url,author,isDraft,mergeStateStatus,mergeable,statusCheckRollup" 2>$null | ConvertFrom-Json)
}

function Checks-AllOk($p){
  $roll=@($p.statusCheckRollup); if($roll.Count -eq 0){ return $false }
  foreach($c in $roll){ if($c.conclusion -notin @("SUCCESS","SKIPPED","NEUTRAL")){ return $false } }
  return $true
}

function Get-PrFiles([string]$repo,[int]$n){
  $api="repos/$repo/pulls/$n/files?per_page=100"
  $raw=(& gh api $api 2>$null | Out-String).Trim()
  if(-not $raw){ return @() }
  $arr=@($raw | ConvertFrom-Json)
  $files=@(); foreach($x in $arr){ if($x.filename){ $files+=[string]$x.filename } }
  return $files
}

function Is-SafeDocsOnly([string[]]$files){
  if($files.Count -eq 0){ return $false }
  foreach($f in $files){ if($f -like "docs/MEP/*"){ continue }; if($f -eq "START_HERE.md"){ continue }; return $false }
  return $true
}

function Extract-FailedRunIds($p){
  $ids=New-Object System.Collections.Generic.HashSet[string]
  foreach($c in @($p.statusCheckRollup)){ if($c.conclusion -ne "FAILURE"){ continue }; $u=$c.detailsUrl; if(-not $u){ continue }; $m=[regex]::Match($u,"actions/runs/(\d+)"); if($m.Success){ [void]$ids.Add($m.Groups[1].Value) } }
  return @($ids)
}

function Rerun-Run([string]$repo,[string]$runId){ & gh run rerun $runId --repo $repo --failed 2>$null | Out-Null }
function Wait-Run([string]$repo,[string]$runId,[int]$maxRounds,[int]$sleepSec){
  for($i=1;$i -le $maxRounds;$i++){
    $raw=(& gh run view $runId --repo $repo --json "status,conclusion" 2>$null | Out-String).Trim()
    if($raw){ $r=$raw|ConvertFrom-Json; if($r.status -eq "completed"){ return $r } }
    Start-Sleep -Seconds $sleepSec
  }
  return $null
}

# ===== main =====
Sync-MainHard
$repo=Get-Repo
$createdAtUtc=(Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
$head=(git rev-parse --short HEAD).Trim()
$idRand=([Guid]::NewGuid().ToString("N").Substring(0,8))
$handoffId=("HOF:{0}-{1}-{2}" -f (Get-Date -Format "yyyyMMdd-HHmmss"),$head,$idRand)

for($round=1; $round -le $MaxRounds; $round++){
  Sync-MainHard
  $open=@(List-OpenPrs $repo)
  if($open.Count -eq 0){ break }
  Write-Host ("[self-heal {0}/{1}] open PR(base main)={2}" -f $round,$MaxRounds,$open.Count)
  foreach($x in $open){
    $n=[int]$x.number
    $files=@(Get-PrFiles $repo $n)
    if(-not (Is-SafeDocsOnly $files)){
      Write-Host ("STOP: non-docs change PR exists: #{0} {1} {2}" -f $n,$x.title,$x.url)
      Write-Host "changed files:"; foreach($f in $files){ Write-Host ("- {0}" -f $f) }
      throw "Not 100/100. Stop."
    }
    for($attempt=1; $attempt -le 3; $attempt++){
      $p=Get-PrView $repo $n; if(-not $p){ throw ("Failed to read PR #{0}" -f $n) }
      if(Checks-AllOk $p){ break }
      $failed=@(Extract-FailedRunIds $p)
      foreach($rid in $failed){
        Write-Host ("RERUN: runId={0} (https://github.com/{1}/actions/runs/{0})" -f $rid,$repo)
        Rerun-Run $repo $rid
        $r=Wait-Run $repo $rid $WaitRounds $SleepSec
        if(-not $r){ throw ("STOP: timeout runId={0}" -f $rid) }
        if($r.conclusion -ne "success"){ throw ("STOP: run still failing runId={0}" -f $rid) }
      }
    }
    $p=Get-PrView $repo $n; if(-not (Checks-AllOk $p)){ throw ("STOP: checks still not OK: #{0} {1}" -f $n,$x.url) }
    Write-Host ("MERGE: #{0} {1}" -f $n,$x.url)
    & gh pr merge $n --repo $repo --squash --delete-branch 2>$null | Out-Null
  }
}

Sync-MainHard
$open=@(List-OpenPrs $repo)
$openCount=$open.Count
$biz="platform/MEP/03_BUSINESS/よりそい堂/business_spec.md"
$requiredHeadings=@("## Order Lifecycle Controls（Phase-2）— 欠番/削除/復旧/誤完了解除（トゥームストーン方式）","### タスク投影（Todoist/ClickUp）— ライフサイクル表示と完了/復旧（固定）","### コメントモード（モード固定）— 入力待ち・実行・キャンセル（Phase-2｜固定）","### トリガー一覧（Phase-2｜固定）","### 欠番/削除モード（最終仕様）— FIX連携・解放/凍結境界・復旧（Phase-2｜固定）")
$missing=@(); if(Test-Path $biz){ $txt=Get-Content -Raw -Encoding UTF8 $biz; foreach($h in $requiredHeadings){ if($txt -notlike ("*"+$h+"*")){ $missing+=$h } } } else { $missing=$requiredHeadings }
$requiredPrs=@(535,539,541,542,543,544)
$bad=@(); foreach($n in $requiredPrs){ try { $p=(gh pr view $n --repo $repo --json "state,baseRefName,mergedAt" 2>$null|ConvertFrom-Json); $ok=($p.state -eq "MERGED" -and $p.baseRefName -eq "main" -and $p.mergedAt); if(-not $ok){ $bad+=$n } } catch { $bad+=$n } }
$score=100; if($openCount -gt 0){ $score-=20 }; if($missing.Count -gt 0){ $score-=30 }; if($bad.Count -gt 0){ $score-=30 }; if($score -lt 0){ $score=0 }
if($score -ne 100){ Write-Host ("HANDOFF_ID: {0}" -f $handoffId); Write-Host ("CREATED_AT_UTC: {0}" -f $createdAtUtc); Write-Host ("HANDOFF_SCORE={0}/100" -f $score); Write-Host ("- open PR(base main)={0}" -f $openCount); if($openCount -gt 0){ foreach($x in $open){ $a=""; try{$a=$x.author.login}catch{}; Write-Host ("  - #{0} {1} ({2}) {3}" -f $x.number,$x.title,$a,$x.url) } }; throw "Not 100/100. Stop." }
$head=(git rev-parse --short HEAD).Trim()
$out=New-Object System.Collections.Generic.List[string]
$out.Add("HANDOFF_ID: " + $handoffId)
$out.Add("CREATED_AT_UTC: " + $createdAtUtc)
$out.Add("REPO: " + $repo)
$out.Add("HEAD: " + $head)
$out.Add("OPEN_PR: 0")
$out.Add("HANDOFF_SCORE=100/100")
$out.Add("BUNDLE: docs/MEP/CHAT_PACKET_BUNDLE.md")
$out.Add("")
$out.Add("【CURRENT｜引っ越し再開用】")
$out.Add("")
$out.Add("Repo: " + $repo)
$out.Add("状態: main clean / open PR 0 / 最新HEAD=" + $head)
$out.Add("")
$out.Add("完了（main反映済み）")
$out.Add("- Comment Concierge / 欠番・削除・トリガー・モード運用は business_spec 側で仕様確定済み（PR #535/#539/#541/#542/#543/#544 が main=MERGED）")
$out.Add("- 次の作業（推奨）：実装計画へ移行（削除モード/FREEZE/Request(FIX) の「台帳反映（列/ステータス/ログ）」を master_spec 側へ落とす：1テーマ=1PR）")
$packet = ($out -join "`n") + "`n"
Write-Host $packet
_tmp -is [System.Array]) { $n = [int]# MEP HANDOFF (NO-DRIFT) v3.3 (self-heal docs PRs; no here-strings; no GraphQL)
# - 100/100 以外は CURRENT を出さない（汚染停止）。
# - open PR が残っている場合、docs/MEP/** と START_HERE.md のみ変更するPRに限り自動収束（checks待ち + rerun failure + merge）。
# - docs/MEP 以外の変更を含む open PR があれば即停止（人間判断）。

param([switch]$WithIssue,[int]$IssueNumber=0,[int]$MaxRounds=6,[int]$SleepSec=5,[int]$WaitRounds=60)
$ErrorActionPreference="Stop"
$ProgressPreference="SilentlyContinue"
$env:GH_PAGER="cat"
[Console]::OutputEncoding=[System.Text.Encoding]::UTF8
try { $PSNativeCommandUseErrorActionPreference = $false } catch {}
function Need($cmd){ if(-not (Get-Command $cmd -ErrorAction SilentlyContinue)){ throw "Missing command: $cmd" } }
Need git; Need gh; if(-not (Test-Path ".git")){ throw "Run at repo root (where .git exists)." }

function Sync-MainHard {
  cmd /c "git rebase --abort 1>nul 2>nul" | Out-Null
  cmd /c "git merge  --abort 1>nul 2>nul" | Out-Null
  cmd /c "git cherry-pick --abort 1>nul 2>nul" | Out-Null
  cmd /c "git fetch origin main 1>nul 2>nul" | Out-Null
  cmd /c "git checkout main 1>nul 2>nul" | Out-Null
  cmd /c "git reset --hard origin/main 1>nul 2>nul" | Out-Null
  cmd /c "git clean -fd 1>nul 2>nul" | Out-Null
  if(git status --porcelain){ throw "Working tree is not clean after reset (locks/R/O likely). Close OneDrive/editor locks and retry." }
}

function Get-Repo {
  $raw = (& gh repo view --json nameWithOwner 2>$null | Out-String).Trim()
  if(-not $raw){ throw "gh repo view failed. Run: gh auth status" }
  return ((($raw | ConvertFrom-Json).nameWithOwner) | Out-String).Trim()
}

function List-OpenPrs([string]$repo){
  $raw = (& gh pr list --repo $repo --state open --base main --limit 200 --json "number,title,url,author,isDraft" 2>$null | Out-String).Trim()
  if(-not $raw){ return @() }
  if(-not $raw.StartsWith("[")){ throw "PR list JSON corrupted (not an array). Stop to prevent drift." }
  return @($raw | ConvertFrom-Json)
}

function Get-PrView([string]$repo,[int]$n){
  return (gh pr view $n --repo $repo --json "number,title,url,author,isDraft,mergeStateStatus,mergeable,statusCheckRollup" 2>$null | ConvertFrom-Json)
}

function Checks-AllOk($p){
  $roll=@($p.statusCheckRollup); if($roll.Count -eq 0){ return $false }
  foreach($c in $roll){ if($c.conclusion -notin @("SUCCESS","SKIPPED","NEUTRAL")){ return $false } }
  return $true
}

function Get-PrFiles([string]$repo,[int]$n){
  $api="repos/$repo/pulls/$n/files?per_page=100"
  $raw=(& gh api $api 2>$null | Out-String).Trim()
  if(-not $raw){ return @() }
  $arr=@($raw | ConvertFrom-Json)
  $files=@(); foreach($x in $arr){ if($x.filename){ $files+=[string]$x.filename } }
  return $files
}

function Is-SafeDocsOnly([string[]]$files){
  if($files.Count -eq 0){ return $false }
  foreach($f in $files){ if($f -like "docs/MEP/*"){ continue }; if($f -eq "START_HERE.md"){ continue }; return $false }
  return $true
}

function Extract-FailedRunIds($p){
  $ids=New-Object System.Collections.Generic.HashSet[string]
  foreach($c in @($p.statusCheckRollup)){ if($c.conclusion -ne "FAILURE"){ continue }; $u=$c.detailsUrl; if(-not $u){ continue }; $m=[regex]::Match($u,"actions/runs/(\d+)"); if($m.Success){ [void]$ids.Add($m.Groups[1].Value) } }
  return @($ids)
}

function Rerun-Run([string]$repo,[string]$runId){ & gh run rerun $runId --repo $repo --failed 2>$null | Out-Null }
function Wait-Run([string]$repo,[string]$runId,[int]$maxRounds,[int]$sleepSec){
  for($i=1;$i -le $maxRounds;$i++){
    $raw=(& gh run view $runId --repo $repo --json "status,conclusion" 2>$null | Out-String).Trim()
    if($raw){ $r=$raw|ConvertFrom-Json; if($r.status -eq "completed"){ return $r } }
    Start-Sleep -Seconds $sleepSec
  }
  return $null
}

# ===== main =====
Sync-MainHard
$repo=Get-Repo
$createdAtUtc=(Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
$head=(git rev-parse --short HEAD).Trim()
$idRand=([Guid]::NewGuid().ToString("N").Substring(0,8))
$handoffId=("HOF:{0}-{1}-{2}" -f (Get-Date -Format "yyyyMMdd-HHmmss"),$head,$idRand)

for($round=1; $round -le $MaxRounds; $round++){
  Sync-MainHard
  $open=@(List-OpenPrs $repo)
  if($open.Count -eq 0){ break }
  Write-Host ("[self-heal {0}/{1}] open PR(base main)={2}" -f $round,$MaxRounds,$open.Count)
  foreach($x in $open){
    $n=[int]$x.number
    $files=@(Get-PrFiles $repo $n)
    if(-not (Is-SafeDocsOnly $files)){
      Write-Host ("STOP: non-docs change PR exists: #{0} {1} {2}" -f $n,$x.title,$x.url)
      Write-Host "changed files:"; foreach($f in $files){ Write-Host ("- {0}" -f $f) }
      throw "Not 100/100. Stop."
    }
    for($attempt=1; $attempt -le 3; $attempt++){
      $p=Get-PrView $repo $n; if(-not $p){ throw ("Failed to read PR #{0}" -f $n) }
      if(Checks-AllOk $p){ break }
      $failed=@(Extract-FailedRunIds $p)
      foreach($rid in $failed){
        Write-Host ("RERUN: runId={0} (https://github.com/{1}/actions/runs/{0})" -f $rid,$repo)
        Rerun-Run $repo $rid
        $r=Wait-Run $repo $rid $WaitRounds $SleepSec
        if(-not $r){ throw ("STOP: timeout runId={0}" -f $rid) }
        if($r.conclusion -ne "success"){ throw ("STOP: run still failing runId={0}" -f $rid) }
      }
    }
    $p=Get-PrView $repo $n; if(-not (Checks-AllOk $p)){ throw ("STOP: checks still not OK: #{0} {1}" -f $n,$x.url) }
    Write-Host ("MERGE: #{0} {1}" -f $n,$x.url)
    & gh pr merge $n --repo $repo --squash --delete-branch 2>$null | Out-Null
  }
}

Sync-MainHard
$open=@(List-OpenPrs $repo)
$openCount=$open.Count
$biz="platform/MEP/03_BUSINESS/よりそい堂/business_spec.md"
$requiredHeadings=@("## Order Lifecycle Controls（Phase-2）— 欠番/削除/復旧/誤完了解除（トゥームストーン方式）","### タスク投影（Todoist/ClickUp）— ライフサイクル表示と完了/復旧（固定）","### コメントモード（モード固定）— 入力待ち・実行・キャンセル（Phase-2｜固定）","### トリガー一覧（Phase-2｜固定）","### 欠番/削除モード（最終仕様）— FIX連携・解放/凍結境界・復旧（Phase-2｜固定）")
$missing=@(); if(Test-Path $biz){ $txt=Get-Content -Raw -Encoding UTF8 $biz; foreach($h in $requiredHeadings){ if($txt -notlike ("*"+$h+"*")){ $missing+=$h } } } else { $missing=$requiredHeadings }
$requiredPrs=@(535,539,541,542,543,544)
$bad=@(); foreach($n in $requiredPrs){ try { $p=(gh pr view $n --repo $repo --json "state,baseRefName,mergedAt" 2>$null|ConvertFrom-Json); $ok=($p.state -eq "MERGED" -and $p.baseRefName -eq "main" -and $p.mergedAt); if(-not $ok){ $bad+=$n } } catch { $bad+=$n } }
$score=100; if($openCount -gt 0){ $score-=20 }; if($missing.Count -gt 0){ $score-=30 }; if($bad.Count -gt 0){ $score-=30 }; if($score -lt 0){ $score=0 }
if($score -ne 100){ Write-Host ("HANDOFF_ID: {0}" -f $handoffId); Write-Host ("CREATED_AT_UTC: {0}" -f $createdAtUtc); Write-Host ("HANDOFF_SCORE={0}/100" -f $score); Write-Host ("- open PR(base main)={0}" -f $openCount); if($openCount -gt 0){ foreach($x in $open){ $a=""; try{$a=$x.author.login}catch{}; Write-Host ("  - #{0} {1} ({2}) {3}" -f $x.number,$x.title,$a,$x.url) } }; throw "Not 100/100. Stop." }
$head=(git rev-parse --short HEAD).Trim()
$out=New-Object System.Collections.Generic.List[string]
$out.Add("HANDOFF_ID: " + $handoffId)
$out.Add("CREATED_AT_UTC: " + $createdAtUtc)
$out.Add("REPO: " + $repo)
$out.Add("HEAD: " + $head)
$out.Add("OPEN_PR: 0")
$out.Add("HANDOFF_SCORE=100/100")
$out.Add("BUNDLE: docs/MEP/CHAT_PACKET_BUNDLE.md")
$out.Add("")
$out.Add("【CURRENT｜引っ越し再開用】")
$out.Add("")
$out.Add("Repo: " + $repo)
$out.Add("状態: main clean / open PR 0 / 最新HEAD=" + $head)
$out.Add("")
$out.Add("完了（main反映済み）")
$out.Add("- Comment Concierge / 欠番・削除・トリガー・モード運用は business_spec 側で仕様確定済み（PR #535/#539/#541/#542/#543/#544 が main=MERGED）")
$out.Add("- 次の作業（推奨）：実装計画へ移行（削除モード/FREEZE/Request(FIX) の「台帳反映（列/ステータス/ログ）」を master_spec 側へ落とす：1テーマ=1PR）")
$packet = ($out -join "`n") + "`n"
Write-Host $packet
_tmp[0] } else { $n = [int]# MEP HANDOFF (NO-DRIFT) v3.3 (self-heal docs PRs; no here-strings; no GraphQL)
# - 100/100 以外は CURRENT を出さない（汚染停止）。
# - open PR が残っている場合、docs/MEP/** と START_HERE.md のみ変更するPRに限り自動収束（checks待ち + rerun failure + merge）。
# - docs/MEP 以外の変更を含む open PR があれば即停止（人間判断）。

param([switch]$WithIssue,[int]$IssueNumber=0,[int]$MaxRounds=6,[int]$SleepSec=5,[int]$WaitRounds=60)
$ErrorActionPreference="Stop"
$ProgressPreference="SilentlyContinue"
$env:GH_PAGER="cat"
[Console]::OutputEncoding=[System.Text.Encoding]::UTF8
try { $PSNativeCommandUseErrorActionPreference = $false } catch {}
function Need($cmd){ if(-not (Get-Command $cmd -ErrorAction SilentlyContinue)){ throw "Missing command: $cmd" } }
Need git; Need gh; if(-not (Test-Path ".git")){ throw "Run at repo root (where .git exists)." }

function Sync-MainHard {
  cmd /c "git rebase --abort 1>nul 2>nul" | Out-Null
  cmd /c "git merge  --abort 1>nul 2>nul" | Out-Null
  cmd /c "git cherry-pick --abort 1>nul 2>nul" | Out-Null
  cmd /c "git fetch origin main 1>nul 2>nul" | Out-Null
  cmd /c "git checkout main 1>nul 2>nul" | Out-Null
  cmd /c "git reset --hard origin/main 1>nul 2>nul" | Out-Null
  cmd /c "git clean -fd 1>nul 2>nul" | Out-Null
  if(git status --porcelain){ throw "Working tree is not clean after reset (locks/R/O likely). Close OneDrive/editor locks and retry." }
}

function Get-Repo {
  $raw = (& gh repo view --json nameWithOwner 2>$null | Out-String).Trim()
  if(-not $raw){ throw "gh repo view failed. Run: gh auth status" }
  return ((($raw | ConvertFrom-Json).nameWithOwner) | Out-String).Trim()
}

function List-OpenPrs([string]$repo){
  $raw = (& gh pr list --repo $repo --state open --base main --limit 200 --json "number,title,url,author,isDraft" 2>$null | Out-String).Trim()
  if(-not $raw){ return @() }
  if(-not $raw.StartsWith("[")){ throw "PR list JSON corrupted (not an array). Stop to prevent drift." }
  return @($raw | ConvertFrom-Json)
}

function Get-PrView([string]$repo,[int]$n){
  return (gh pr view $n --repo $repo --json "number,title,url,author,isDraft,mergeStateStatus,mergeable,statusCheckRollup" 2>$null | ConvertFrom-Json)
}

function Checks-AllOk($p){
  $roll=@($p.statusCheckRollup); if($roll.Count -eq 0){ return $false }
  foreach($c in $roll){ if($c.conclusion -notin @("SUCCESS","SKIPPED","NEUTRAL")){ return $false } }
  return $true
}

function Get-PrFiles([string]$repo,[int]$n){
  $api="repos/$repo/pulls/$n/files?per_page=100"
  $raw=(& gh api $api 2>$null | Out-String).Trim()
  if(-not $raw){ return @() }
  $arr=@($raw | ConvertFrom-Json)
  $files=@(); foreach($x in $arr){ if($x.filename){ $files+=[string]$x.filename } }
  return $files
}

function Is-SafeDocsOnly([string[]]$files){
  if($files.Count -eq 0){ return $false }
  foreach($f in $files){ if($f -like "docs/MEP/*"){ continue }; if($f -eq "START_HERE.md"){ continue }; return $false }
  return $true
}

function Extract-FailedRunIds($p){
  $ids=New-Object System.Collections.Generic.HashSet[string]
  foreach($c in @($p.statusCheckRollup)){ if($c.conclusion -ne "FAILURE"){ continue }; $u=$c.detailsUrl; if(-not $u){ continue }; $m=[regex]::Match($u,"actions/runs/(\d+)"); if($m.Success){ [void]$ids.Add($m.Groups[1].Value) } }
  return @($ids)
}

function Rerun-Run([string]$repo,[string]$runId){ & gh run rerun $runId --repo $repo --failed 2>$null | Out-Null }
function Wait-Run([string]$repo,[string]$runId,[int]$maxRounds,[int]$sleepSec){
  for($i=1;$i -le $maxRounds;$i++){
    $raw=(& gh run view $runId --repo $repo --json "status,conclusion" 2>$null | Out-String).Trim()
    if($raw){ $r=$raw|ConvertFrom-Json; if($r.status -eq "completed"){ return $r } }
    Start-Sleep -Seconds $sleepSec
  }
  return $null
}

# ===== main =====
Sync-MainHard
$repo=Get-Repo
$createdAtUtc=(Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
$head=(git rev-parse --short HEAD).Trim()
$idRand=([Guid]::NewGuid().ToString("N").Substring(0,8))
$handoffId=("HOF:{0}-{1}-{2}" -f (Get-Date -Format "yyyyMMdd-HHmmss"),$head,$idRand)

for($round=1; $round -le $MaxRounds; $round++){
  Sync-MainHard
  $open=@(List-OpenPrs $repo)
  if($open.Count -eq 0){ break }
  Write-Host ("[self-heal {0}/{1}] open PR(base main)={2}" -f $round,$MaxRounds,$open.Count)
  foreach($x in $open){
    $n=[int]$x.number
    $files=@(Get-PrFiles $repo $n)
    if(-not (Is-SafeDocsOnly $files)){
      Write-Host ("STOP: non-docs change PR exists: #{0} {1} {2}" -f $n,$x.title,$x.url)
      Write-Host "changed files:"; foreach($f in $files){ Write-Host ("- {0}" -f $f) }
      throw "Not 100/100. Stop."
    }
    for($attempt=1; $attempt -le 3; $attempt++){
      $p=Get-PrView $repo $n; if(-not $p){ throw ("Failed to read PR #{0}" -f $n) }
      if(Checks-AllOk $p){ break }
      $failed=@(Extract-FailedRunIds $p)
      foreach($rid in $failed){
        Write-Host ("RERUN: runId={0} (https://github.com/{1}/actions/runs/{0})" -f $rid,$repo)
        Rerun-Run $repo $rid
        $r=Wait-Run $repo $rid $WaitRounds $SleepSec
        if(-not $r){ throw ("STOP: timeout runId={0}" -f $rid) }
        if($r.conclusion -ne "success"){ throw ("STOP: run still failing runId={0}" -f $rid) }
      }
    }
    $p=Get-PrView $repo $n; if(-not (Checks-AllOk $p)){ throw ("STOP: checks still not OK: #{0} {1}" -f $n,$x.url) }
    Write-Host ("MERGE: #{0} {1}" -f $n,$x.url)
    & gh pr merge $n --repo $repo --squash --delete-branch 2>$null | Out-Null
  }
}

Sync-MainHard
$open=@(List-OpenPrs $repo)
$openCount=$open.Count
$biz="platform/MEP/03_BUSINESS/よりそい堂/business_spec.md"
$requiredHeadings=@("## Order Lifecycle Controls（Phase-2）— 欠番/削除/復旧/誤完了解除（トゥームストーン方式）","### タスク投影（Todoist/ClickUp）— ライフサイクル表示と完了/復旧（固定）","### コメントモード（モード固定）— 入力待ち・実行・キャンセル（Phase-2｜固定）","### トリガー一覧（Phase-2｜固定）","### 欠番/削除モード（最終仕様）— FIX連携・解放/凍結境界・復旧（Phase-2｜固定）")
$missing=@(); if(Test-Path $biz){ $txt=Get-Content -Raw -Encoding UTF8 $biz; foreach($h in $requiredHeadings){ if($txt -notlike ("*"+$h+"*")){ $missing+=$h } } } else { $missing=$requiredHeadings }
$requiredPrs=@(535,539,541,542,543,544)
$bad=@(); foreach($n in $requiredPrs){ try { $p=(gh pr view $n --repo $repo --json "state,baseRefName,mergedAt" 2>$null|ConvertFrom-Json); $ok=($p.state -eq "MERGED" -and $p.baseRefName -eq "main" -and $p.mergedAt); if(-not $ok){ $bad+=$n } } catch { $bad+=$n } }
$score=100; if($openCount -gt 0){ $score-=20 }; if($missing.Count -gt 0){ $score-=30 }; if($bad.Count -gt 0){ $score-=30 }; if($score -lt 0){ $score=0 }
if($score -ne 100){ Write-Host ("HANDOFF_ID: {0}" -f $handoffId); Write-Host ("CREATED_AT_UTC: {0}" -f $createdAtUtc); Write-Host ("HANDOFF_SCORE={0}/100" -f $score); Write-Host ("- open PR(base main)={0}" -f $openCount); if($openCount -gt 0){ foreach($x in $open){ $a=""; try{$a=$x.author.login}catch{}; Write-Host ("  - #{0} {1} ({2}) {3}" -f $x.number,$x.title,$a,$x.url) } }; throw "Not 100/100. Stop." }
$head=(git rev-parse --short HEAD).Trim()
$out=New-Object System.Collections.Generic.List[string]
$out.Add("HANDOFF_ID: " + $handoffId)
$out.Add("CREATED_AT_UTC: " + $createdAtUtc)
$out.Add("REPO: " + $repo)
$out.Add("HEAD: " + $head)
$out.Add("OPEN_PR: 0")
$out.Add("HANDOFF_SCORE=100/100")
$out.Add("BUNDLE: docs/MEP/CHAT_PACKET_BUNDLE.md")
$out.Add("")
$out.Add("【CURRENT｜引っ越し再開用】")
$out.Add("")
$out.Add("Repo: " + $repo)
$out.Add("状態: main clean / open PR 0 / 最新HEAD=" + $head)
$out.Add("")
$out.Add("完了（main反映済み）")
$out.Add("- Comment Concierge / 欠番・削除・トリガー・モード運用は business_spec 側で仕様確定済み（PR #535/#539/#541/#542/#543/#544 が main=MERGED）")
$out.Add("- 次の作業（推奨）：実装計画へ移行（削除モード/FREEZE/Request(FIX) の「台帳反映（列/ステータス/ログ）」を master_spec 側へ落とす：1テーマ=1PR）")
$packet = ($out -join "`n") + "`n"
Write-Host $packet
_tmp }
    $files=@(Get-PrFiles $repo $n)
    if(-not (Is-SafeDocsOnly $files)){
      Write-Host ("STOP: non-docs change PR exists: #{0} {1} {2}" -f $n,$x.title,$x.url)
      Write-Host "changed files:"; foreach($f in $files){ Write-Host ("- {0}" -f $f) }
      throw "Not 100/100. Stop."
    }
    for($attempt=1; $attempt -le 3; $attempt++){
      $p=Get-PrView $repo $n; if(-not $p){ throw ("Failed to read PR #{0}" -f $n) }
      if(Checks-AllOk $p){ break }
      $failed=@(Extract-FailedRunIds $p)
      foreach($rid in $failed){
        Write-Host ("RERUN: runId={0} (https://github.com/{1}/actions/runs/{0})" -f $rid,$repo)
        Rerun-Run $repo $rid
        $r=Wait-Run $repo $rid $WaitRounds $SleepSec
        if(-not $r){ throw ("STOP: timeout runId={0}" -f $rid) }
        if($r.conclusion -ne "success"){ throw ("STOP: run still failing runId={0}" -f $rid) }
      }
    }
    $p=Get-PrView $repo $n; if(-not (Checks-AllOk $p)){ throw ("STOP: checks still not OK: #{0} {1}" -f $n,$x.url) }
    Write-Host ("MERGE: #{0} {1}" -f $n,$x.url)
    & gh pr merge $n --repo $repo --squash --delete-branch 2>$null | Out-Null
  }
}

Sync-MainHard
$open=@(List-OpenPrs $repo)
$openCount=$open.Count
$biz="platform/MEP/03_BUSINESS/よりそい堂/business_spec.md"
$requiredHeadings=@("## Order Lifecycle Controls（Phase-2）— 欠番/削除/復旧/誤完了解除（トゥームストーン方式）","### タスク投影（Todoist/ClickUp）— ライフサイクル表示と完了/復旧（固定）","### コメントモード（モード固定）— 入力待ち・実行・キャンセル（Phase-2｜固定）","### トリガー一覧（Phase-2｜固定）","### 欠番/削除モード（最終仕様）— FIX連携・解放/凍結境界・復旧（Phase-2｜固定）")
$missing=@(); if(Test-Path $biz){ $txt=Get-Content -Raw -Encoding UTF8 $biz; foreach($h in $requiredHeadings){ if($txt -notlike ("*"+$h+"*")){ $missing+=$h } } } else { $missing=$requiredHeadings }
$requiredPrs=@(535,539,541,542,543,544)
$bad=@(); foreach($n in $requiredPrs){ try { $p=(gh pr view $n --repo $repo --json "state,baseRefName,mergedAt" 2>$null|ConvertFrom-Json); $ok=($p.state -eq "MERGED" -and $p.baseRefName -eq "main" -and $p.mergedAt); if(-not $ok){ $bad+=$n } } catch { $bad+=$n } }
$score=100; if($openCount -gt 0){ $score-=20 }; if($missing.Count -gt 0){ $score-=30 }; if($bad.Count -gt 0){ $score-=30 }; if($score -lt 0){ $score=0 }
if($score -ne 100){ Write-Host ("HANDOFF_ID: {0}" -f $handoffId); Write-Host ("CREATED_AT_UTC: {0}" -f $createdAtUtc); Write-Host ("HANDOFF_SCORE={0}/100" -f $score); Write-Host ("- open PR(base main)={0}" -f $openCount); if($openCount -gt 0){ foreach($x in $open){ $a=""; try{$a=$x.author.login}catch{}; Write-Host ("  - #{0} {1} ({2}) {3}" -f $x.number,$x.title,$a,$x.url) } }; throw "Not 100/100. Stop." }
$head=(git rev-parse --short HEAD).Trim()
$out=New-Object System.Collections.Generic.List[string]
$out.Add("HANDOFF_ID: " + $handoffId)
$out.Add("CREATED_AT_UTC: " + $createdAtUtc)
$out.Add("REPO: " + $repo)
$out.Add("HEAD: " + $head)
$out.Add("OPEN_PR: 0")
$out.Add("HANDOFF_SCORE=100/100")
$out.Add("BUNDLE: docs/MEP/CHAT_PACKET_BUNDLE.md")
$out.Add("")
$out.Add("【CURRENT｜引っ越し再開用】")
$out.Add("")
$out.Add("Repo: " + $repo)
$out.Add("状態: main clean / open PR 0 / 最新HEAD=" + $head)
$out.Add("")
$out.Add("完了（main反映済み）")
$out.Add("- Comment Concierge / 欠番・削除・トリガー・モード運用は business_spec 側で仕様確定済み（PR #535/#539/#541/#542/#543/#544 が main=MERGED）")
$out.Add("- 次の作業（推奨）：実装計画へ移行（削除モード/FREEZE/Request(FIX) の「台帳反映（列/ステータス/ログ）」を master_spec 側へ落とす：1テーマ=1PR）")
$packet = ($out -join "`n") + "`n"
Write-Host $packet

