name: Text Integrity Guard

on:
  pull_request:
  workflow_dispatch:
  push:

permissions:
  contents: read

jobs:
  guard:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute base/head
        id: revs
        shell: bash
        run: |
          set -euo pipefail

          # Default
          HEAD="${GITHUB_SHA}"
          BASE=""

          if [ "${GITHUB_EVENT_NAME}" = "pull_request" ]; then
            BASE="${{ github.event.pull_request.base.sha }}"
          elif [ "${GITHUB_EVENT_NAME}" = "push" ]; then
            # push event has "before"
            BASE="${{ github.event.before }}"
            # In some cases (first push/new branch), BASE can be 0000...; fallback to HEAD^
            if [ -z "$BASE" ] || echo "$BASE" | grep -qE '^0+$'; then
              BASE="$(git rev-parse "${HEAD}^" 2>/dev/null || true)"
            fi
          fi

          if [ -z "$BASE" ]; then
            echo "BASE is empty (cannot diff). Treat as OK and exit."
            echo "base=" >> "$GITHUB_OUTPUT"
            echo "head=$HEAD" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "base=$BASE" >> "$GITHUB_OUTPUT"
          echo "head=$HEAD" >> "$GITHUB_OUTPUT"
          echo "BASE=$BASE"
          echo "HEAD=$HEAD"

      - name: Detect changed files
        id: changed
        shell: bash
        run: |
          set -euo pipefail
          BASE="${{ steps.revs.outputs.base }}"
          HEAD="${{ steps.revs.outputs.head }}"

          if [ -z "$BASE" ]; then
            echo "No base -> no changed files"
            : > changed_files.txt
            exit 0
          fi

          git diff --name-only "$BASE...$HEAD" > changed_files.txt
          echo "Changed files:"
          cat changed_files.txt || true

      - name: Validate encoding / EOL / newline and tripwire on large diffs
        shell: bash
        run: |
          set -euo pipefail
          BASE="${{ steps.revs.outputs.base }}"
          HEAD="${{ steps.revs.outputs.head }}"

          # Files that are extremely sensitive to accidental rewrites
          SENSITIVE_REGEX='(^|/)(master_spec|ui_spec\.md)-Raw'

          fail=0

          while IFS= read -r f; do
            [ -z "$f" ] && continue
            [ ! -f "$f" ] && continue

            # Only check text-like files (md + sensitive)
            if [[ "$f" == *.md ]] || [[ "$f" =~ $SENSITIVE_REGEX ]]; then
              # 1) CR (\r) must not exist
              if python3 - <<'PY' "$f"
import sys
p=sys.argv[1]
b=open(p,'rb').read()
sys.exit(1 if b.find(b'\r')!=-1 else 0)
PY
              then
                :
              else
                echo "NG: CRLF/CR detected in $f"
                fail=1
              fi

              # 2) Must be valid UTF-8
              python3 - <<'PY' "$f" || (echo "NG: invalid UTF-8 in $f"; exit 1)
import sys
p=sys.argv[1]
open(p,'rb').read().decode('utf-8')
PY

              # 3) Must end with newline (if non-empty)
              python3 - <<'PY' "$f" || (echo "NG: missing final newline in $f"; exit 1)
import sys
p=sys.argv[1]
b=open(p,'rb').read()
if len(b)>0 and b[-1:]!=b'\n':
  raise SystemExit(1)
PY
            fi

            # 4) Tripwire: if sensitive file changed, block huge diff (accidental rewrite)
            if [[ "$f" =~ $SENSITIVE_REGEX ]] && [ -n "$BASE" ]; then
              numstat=$(git diff --numstat "$BASE...$HEAD" -- "$f" | awk '{print $1" "$2}')
              ins=$(echo "$numstat" | awk '{print $1}')
              del=$(echo "$numstat" | awk '{print $2}')
              ins=${ins:-0}; del=${del:-0}
              total=$((ins+del))
              echo "SENSITIVE_DIFF $f: +$ins -$del (total=$total)"

              # threshold: stops mojibake/full-rewrite accidents
              if [ "$total" -gt 200 ]; then
                echo "NG: large diff detected on sensitive file ($f). total=$total > 200"
                fail=1
              fi
            fi

          done < changed_files.txt

          if [ "$fail" -ne 0 ]; then
            echo "Text Integrity Guard: FAILED"
            exit 1
          fi

          echo "Text Integrity Guard: OK"